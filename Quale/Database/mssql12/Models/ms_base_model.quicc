
<#dialect(mssql12) #>

<#:model()

/******************** DOMAINS *********************/
 
 
/****************** GENERATORS ********************/


CREATE GENERATOR Z$PK_GEN;
SET GENERATOR Z$PK_GEN TO 1000001;

/* QUICC BREAK; */

CREATE GENERATOR Z$SERVER_NUMBER;
SET GENERATOR Z$SERVER_NUMBER TO 12;


CREATE GENERATOR Z$CONTEXT_SEQ;
SET GENERATOR Z$CONTEXT_SEQ TO 10000;

CREATE GENERATOR Z$SP_INDEX;
SET GENERATOR Z$SP_INDEX TO 1;




/******************** TABLES **********************/





/******************** TRIGGERS ********************/
SET TERM ^ ;
CREATE OR ALTER TRIGGER Z$SP_IIT ON Z$SP INSTEAD OF INSERT AS
BEGIN
  SET NOCOUNT ON;
  /*we increment by 1000 as we have sub procedures that are indexed relative to this index*/
  select * into #tmp from inserted;
  UPDATE #tmp SET PK = 1000* (NEXT VALUE FOR  Z$SP_INDEX )+1 where PK is null; 
  insert into Z$SP select * from #tmp;
END^
SET TERM ; ^

-- --------------------------------------------------------------------------------
SET TERM ^ ;
CREATE OR ALTER TRIGGER Z$DICTIONARY_IIT ON Z$DICTIONARY INSTEAD OF INSERT AS
BEGIN
  SET NOCOUNT ON;  
  select * into #tmp from inserted;
  UPDATE #tmp SET PK = (NEXT VALUE FOR  Z$PK_GEN ) where PK is null; 
  insert into Z$DICTIONARY select * from #tmp;
END^
SET TERM ; ^

-- --------------------------------------------------------------------------------
SET TERM ^ ;
CREATE OR ALTER TRIGGER user_table_name_IIT ON user_table_name INSTEAD OF INSERT AS
BEGIN
  SET NOCOUNT ON;  
  select * into #tmp from inserted;
  UPDATE #tmp SET user_pk_field = (NEXT VALUE FOR  Z$PK_GEN ) where user_pk_field is null; 
  insert into user_table_name select * from #tmp;
END^
SET TERM ; ^

-- --------------------------------------------------------------------------------


/******************* PROCEDURES ******************/




-- --------------------------------------------------------------------------------
SET TERM ^ ;
CREATE OR ALTER PROCEDURE Z$VARIABLES_UPSERT ( @REF nvarchar(80), @VALU nvarchar(256) )
AS
BEGIN
SET NOCOUNT ON; 
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRAN

UPDATE Z$VARIABLES
SET VALU = @VALU
WHERE REF = @REF

INSERT Z$VARIABLES ( VALU, REF )
SELECT @VALU, @REF
WHERE @@ROWCOUNT=0

COMMIT
END; ^
SET TERM ; ^


-- --------------------------------------------------------------------------------
SET TERM ^ ;
/*test code:

declare @lINFO Varchar(1000)='a';
declare @lCURRENTPAGE Varchar(100);
declare @lpage_params_in Varchar(1000);
declare @lCIDRETURN Integer;
declare @lPKREFRETURN Integer;
declare @res VARCHAR(max);
declare @ScriptNamed Varchar(1000);
declare @page_params Varchar(1000);
declare @IN_CID Integer;
declare @IN_PKREF Integer;
EXEC Z$RUN_SUP 'fS+1id3zbr6TCgZdgpPsyg==.0', 1000,0,  'u05guestp05gu35tw00x00',@lCIDRETURN output,  @lINFO output, @res output, @lCURRENTPAGE output
-- EXEC Z$RUN_SUB 'fS+1id3zbr6TCgZdgpPsyg==.0', 1000,0,  'u05guestp05gu35tw00x00',@lINFO output,  @ScriptNamed output, @page_params output, @IN_CID output, @IN_PKREF output
select  @lCIDRETURN as lCIDRETURN,  @lINFO as  lINFO, @res as res, @lCURRENTPAGE as lCURRENTPAGE
select  @lINFO as lINFO,  @ScriptNamed as ScriptNamed, @page_params as page_params, @IN_CID as IN_CID, @IN_PKREF as IN_PKREF
select @lCIDRETURN,@lINFO ,@res,@lCURRENTPAGE as pki
select * from Z$PK_CACHE where indx=120000001
select * from TODO_MVC


*/
CREATE OR ALTER PROCEDURE Z$RUN_SUB(

    @SESSION Varchar(40),
    @CID Integer,
    @PKREF Integer,
    @UPDATES VARCHAR(max) ,

    @INFO Varchar(1000) OUT,
    @CURRENTPAGE Varchar(100) OUT,
    @page_params_in Varchar(1000) OUT,
    @CIDRETURN Integer OUT,
    @PKREFRETURN Integer OUT )


 AS
 BEGIN
 SET NOCOUNT ON;
	DECLARE  @o_ref    varchar(40);
	DECLARE  @o_session varchar(40);
	DECLARE  @passw    varchar(20) = '';
	DECLARE  @usern    varchar(20) = '';
	DECLARE  @LANDING_PAGE_R varchar(100) ;
	DECLARE  @table_name varchar(100);
	DECLARE  @target_field_name  varchar(100);
	DECLARE  @target_fields     varchar(100);
	DECLARE  @pk_field_name_local  varchar(100);
	DECLARE  @pk_field_type        nvarchar(100);	
	DECLARE  @pk_val  varchar(100);    
	DECLARE  @current_page_pk  integer;
	DECLARE  @i        integer;
	DECLARE  @update_cid integer;
	DECLARE  @bp        integer;
	DECLARE  @val       varchar(7999);
	DECLARE  @c         integer;
	DECLARE  @len       integer;
	DECLARE  @bt        char(1);
	DECLARE  @pk        integer;
	DECLARE  @pk_val_exec        integer;
	DECLARE  @stmti_exec        nvarchar(1000);	
	DECLARE  @script    VARCHAR(max); 
	DECLARE  @Openstr   varchar(1000);
	DECLARE  @updatelist   VARCHAR(max); 
	DECLARE  @fieldvalue varchar(1000);
	DECLARE  @fieldname  varchar(1000);

	set @currentpage='';
	set @page_params_in='';
	set @CIDRETURN=@CID;
	
	set @INFO = '{}';

	set @bp=1;    
    set @c=0;
    while (@c<1000) begin 
     
        -- set @INFO = concat(@INFO , 'c :'  , @c , '\r');	
        
        set @c=@c+1;
        set @bt=SUBSTRING(@UPDATES,@bp,1);             
        if (@bt>='a') BEGIN /*lower case are short fields*/
				  set @len=CAST(SUBSTRING(@UPDATES,@bp+1,2) AS  INTEGER) ;
                  set @val=SUBSTRING(@UPDATES,@bp+3,@len);        
                  set @bp=@bp+3+@len;              
        END
        ELSE BEGIN
                  set @len=CAST(SUBSTRING(@UPDATES,@bp+1,5) AS  INTEGER);      
                  set @val=SUBSTRING(@UPDATES,@bp+6,@len);        
                  set @bp=@bp+6+@len;              
        END 
          
		set @bt=LOWER(@bt);
		
		
		if (@bt='u')  set @usern=@val ;  		
		else if (@bt='p')  set @passw=@val ;  
		else if (@bt='l')  set @currentpage=@val ;
		else if (@bt='t')  set @Openstr=@val ;	 -- used as temporary storage 		
		else if (@bt='c')  set @update_cid=@val ;  -- used as temporary storage                 
		else if (@bt='k')  set @i=CAST(@val AS  INTEGER); /*Key field update - used as temporary storage                 */
		else if (@bt='r')  /*parameter value from first load Openstr=name*/
				BEGIN
					set @fieldvalue = (concat('params-',@SESSION,'-',@Openstr));
					EXEC Z$VARIABLES_UPSERT @REF=@fieldvalue ,@VALU=@val 
				END
		else if (@bt='v')  /*Key value update - temp cache*/
				BEGIN
					
					-- softcodec code from the compiler	
--					SELECT top 1 @script = COALESCE(b.page_params,'') FROM Z$PK_CACHE b 
--						WHERE b.MASTER = @update_cid AND b.INDX = @i;
					/*TODO mssql soft codec function*/	
--					if (script<>'') 
--						EXECUTE STATEMENT(script)(:val) INTO :val; 
					
					-- val=clean_escape(val);-- not needed we are using paramitzed stament
					update Z$PK_CACHE set new_value=@val , NEW_VALUE_SET=1
						WHERE MASTER = @update_cid AND INDX = @i;		
						
					-- set @INFO = concat(@INFO , 'cr: ' , @val , ' => ' , @update_cid , ' . ' , @i , '\r');	
										
			    END                
		else if (@bt='w')   /*Key value update - write updates per record*/
					BEGIN
					
					-- DECLARE @cache_done INT = FALSE;
					
				    DECLARE cache_cursor cursor for select VALU, QUERY, PK_FIELD_NAME from Z$PK_CACHE b
						WHERE b.MASTER = @update_cid and b.NEW_VALUE_SET=1
						GROUP by b.MASTER,b.NEW_VALUE_SET,b.VALU,b.QUERY,b.PK_FIELD_NAME;					
						
					OPEN cache_cursor;
					FETCH  NEXT FROM cache_cursor INTO @table_name,@pk_val,@pk_field_name_local;					
					WHILE @@FETCH_STATUS = 0  
					BEGIN  					
					
					
						
						set @val = @pk_field_name_local;
						set @script = '@pkv';
						set @updatelist='';
						BEGIN
							-- DECLARE @fields_done INT = FALSE;
							DECLARE fields_cursor cursor 
							for SELECT c.TARGET,c.INDX,c.TARGET_FIELDS,c.TARGET_VALUES FROM Z$PK_CACHE c
								WHERE c.MASTER = @update_cid 
								and c.NEW_VALUE_SET=1
								and c.VALU=@table_name and c.QUERY=@pk_val and c.PK_FIELD_NAME=@pk_field_name_local;
							
								
							-- todo target fields and openstr can be redone as just a second record
							OPEN fields_cursor;
							FETCH NEXT FROM fields_cursor INTO @target_field_name,@i,@target_fields,@Openstr;
							WHILE @@FETCH_STATUS = 0  
							   BEGIN																		
								set @fieldname  = concat(@target_field_name,COALESCE(@target_fields,'') );
								set @fieldvalue = concat('(select a.new_value from Z$PK_CACHE a where a.MASTER =',@update_cid,' AND a.INDX = ',@i,')');																
								set @val = concat(@val,',',@fieldname );									
								set @script = concat(@script , ',', @fieldvalue ,COALESCE(@Openstr,''));                             
								set @updatelist = concat(@updatelist,', ',@target_field_name,'=',@fieldvalue );								
								FETCH NEXT FROM fields_cursor INTO @target_field_name,@i,@target_fields,@Openstr;
							   END; -- fields_loop;					 
							CLOSE fields_cursor;	
							DEALLOCATE fields_cursor 									


							-- fixup pk for insert methods
							if ((@pk_val is null ) or (LEN(@pk_val)<=1)) 
							   BEGIN								   
								    set @pk_val_exec = NEXT VALUE FOR Z$PK_GEN;  
									set @stmti_exec = concat('insert into ',@table_name,' (',@val,') values (',@script,')' );
								END
								ELSE BEGIN
									set @updatelist = SUBSTRING(concat(@updatelist,' ',@target_fields,'=',SUBSTRING(@Openstr,2,9999) ),2,9999);
									set @pk_val_exec=@pk_val;
									set @stmti_exec = concat('update ',@table_name,' set ',@updatelist,' where ',@pk_field_name_local,'=@pkv' );
									
								END 
							set @pk_field_type = N'@pkv nvarchar(100) ' ; -- concat(@pk_field_name_local, N' nvarchar(40) ');
							EXECUTE sp_executesql @stmti_exec , @pk_field_type, @pkv = @pk_val_exec
						--	set @INFO = concat(@INFO , 'EXECUTE: ' ,@stmti_exec , ' => ' ,  @pk_field_type , '\r\n');	
						--	set @INFO = concat(@INFO , 'EXECUTE: ' ,@stmti_exec , ' => ' ,  @pk_val_exec , '\r\n');	

						--	update Z$PK_CACHE set new_value=null,NEW_VALUE_SET=null WHERE MASTER = @update_cid;
						--set @INFO = concat(@INFO , 'clear: '  , ' => ' , @update_cid , ' . ' , @i , '\r');	
							-- Todo trigger based validations will emit erors into a log that can be fed back to the user
						
						END;	


					FETCH  NEXT FROM cache_cursor INTO @table_name,@pk_val,@pk_field_name_local;					
					END -- update_loop;					 
					
					CLOSE cache_cursor;
					DEALLOCATE cache_cursor 
 					END;
 		else 		
			set @c=1001;
		
		
                  
      END; -- while
     -- set @INFO = 'nxt';
	  
	  
	  
	 -- select  usern, passw,PKRef;
    /*part of post updates is creating a new session if login info is supplied*/
    if (@usern='') BEGIN    
			if (@PKREF=-1) begin -- save without refreshing
				  set @info='saved';
				  return ; -- LEAVE proc_label;
				end 			
		
			if (@PKREF<>0) begin -- load in updated page and page parameters
					SELECT top 1 @currentpage = a.target,@page_params_in = COALESCE(a.PAGE_PARAMS,'') FROM Z$PK_CACHE a WHERE a.MASTER = @CID AND a.INDX = @PKREF;              					
					if (@CURRENTPAGE='') begin set @PKRef=0;
					end 	
				end 	
		
		    -- refresh page
			if (@PKREF=0) begin
      -- 			set @INFO = concat(@INFO , ' @CID :'  , @CID , '  @SESSION:' ,@SESSION,'  PKREF:', @PKREF);
			      SELECT top 1 @CID = r.LINKED_FROM_CID, @PKRef = r.LINKED_FROM_INDX FROM Z$CONTEXT r where r.pk=@CID and r.id=@SESSION;
					SELECT top 1 @currentpage = a.target,@page_params_in = concat(COALESCE(a.PAGE_PARAMS,''),@page_params_in) 
					    FROM Z$PK_CACHE a WHERE a.MASTER = @CID AND a.INDX = @PKREF;              				    
				end 
				
	
				
            /*get the new page, and context info */                
           SELECT top 1 @o_ref = r.OPERATOR_REF, @o_session = r.ID FROM Z$CONTEXT r where r.pk=@CID and r.id=@SESSION;                        
           SELECT top 1 @LANDING_PAGE_R = landing_page FROM Z$USER WHERE id = @o_ref;
            
        END 
    
    if (@usern<>'') BEGIN        
        set @o_ref=NULL;
        /*allow them to login even if expired,  the dashboard gives information that they have expired...*/
        select top 1 @o_ref = id,@LANDING_PAGE_R = landing_page from Z$USER where login_name=@usern and passwd=@passw;
        /*if null then select the nobody user */
        if (@o_ref is NULL) begin 
            select top 1 @o_ref = id,@LANDING_PAGE_R = landing_page from Z$USER where login_name='Guest';
         end 	
         -- info=COALESCE(:o_ref,'NULL')||'&'||COALESCE(:LANDING_PAGE_R,'NULL')||'&'||COALESCE(:passw,'NULL')||'&';  suspend;
		IF ( @CURRENTPAGE <> '') BEGIN set @currentpage = concat('//',@LANDING_PAGE_R,@CURRENTPAGE);
        END
        ELSE BEGIN set @currentpage = concat('//',@LANDING_PAGE_R,'/Index');
		END   
		 
        set @current_page_pk=NULL;
		set @pk = NEXT VALUE FOR Z$PK_GEN;  
		
        INSERT INTO Z$CONTEXT (PK, TSTAMP, OPERATOR_REF, ID) VALUES (@pk,GETDATE(), @o_ref, @SESSION );
         
        -- this record is so we can save and reload the first page                    
        INSERT INTO Z$PK_CACHE (MASTER, INDX, FIELD_NAME, VALU,TARGET,QUERY, PAGE_PARAMS)
            VALUES (@pk,0,'click','Z$USER', @CURRENTPAGE , concat('id=''', replace(@o_ref,'''','''''') , ''''),'' );  
                             
        set @CID = @pk;           
          
        END            
        
	  set @PKREFRETURN=@PKREF;
      set @CIDRETURN=@CID;
	
      -- select INFO,currentpage,page_params_in,CIDRETURN,PKREFRETURN;
	  
	  
END^
SET TERM ; ^


-- --------------------------------------------------------------------------------SET TERM ^ ;
CREATE Or alter PROCEDURE Z$RUN_SUP (
    @Z$SESSIONID VARCHAR(40),
    @CID INTEGER,
    @PKREF INTEGER,
    @UPDATES VARCHAR(max),
    
	 @NEW_CID INTEGER OUT,
	 @info VARCHAR(1000) OUT,
	 @res VARCHAR(max) OUT,
	 @ScriptNamed VARCHAR(250) OUT   
    
    )
  AS
  BEGIN
  SET NOCOUNT ON;

	DECLARE @IN_SESSIONID    varchar(40);
	DECLARE @NIN_SESSIONID    nvarchar(40);
	DECLARE @page_params_in    varchar(1000);
	DECLARE @run_procedure    varchar(100);
	
	DECLARE @o_ref    varchar(40);
	DECLARE @currentpage varchar(100) = '';
	DECLARE @current_page_pk  integer;
	DECLARE @exec_script    VARCHAR(max);
	DECLARE @page_params  varchar(1000) = '';  -- retrieved from the database injected into  script at --assign_params 

	DECLARE @script_exec NVARCHAR(250) ;
	DECLARE @script_params NVARCHAR(250) ;
	
	DECLARE @IN_CID INTEGER;	
	DECLARE @IN_PKREF INTEGER;			
	
	set @IN_SESSIONID=@Z$SESSIONID;
	set @page_params_in='';
	set @run_procedure='';

	EXEC Z$RUN_SUB @Z$SESSIONID,@CID,@PKREF,@UPDATES,
	  @INFO output, @ScriptNamed output, @page_params output, @IN_CID output, @IN_PKREF output;
	
    -- select 'a',Z$SESSIONID,CID,PKREF,UPDATES,   info,ScriptNamed,page_params,@IN_CID,@IN_PKREF;
	if (@info='saved') begin -- saved without refreshing				 
				  set @res= '' ;  
				  set @ScriptNamed= '' ;  				   					
				  return;
   		   end 

    /*execute the page or SP*/  

    -- further match language and coy custom files  
	-- SELECT top 1 'sc',ScriptNamed,pk,script FROM Z$SP  where file_name=ScriptNamed   ;
    SELECT top 1 @current_page_pk = pk,@exec_script = script FROM Z$SP  where file_name=@ScriptNamed   ;
	 set @info=concat('to run pk:',@current_page_pk,' sc: ',COALESCE(@exec_script,'null'),' from ',COALESCE(@ScriptNamed,'null'));       
	 
    if (@exec_script is null) begin /*back home or direct to an 404 error page ..?*/         
        SELECT  top 1 @current_page_pk = pk,@exec_script = script FROM Z$SP where 
                file_name=concat('//',(SELECT landing_page FROM Z$USER WHERE id = @o_ref),'/404') ;    
                
    --   set @info=concat('to runx : ',@script_exec,' from ',COALESCE(@ScriptNamed,'null'));                
    end             
    if (@exec_script is null) begin /*global 404 error page */
        SELECT  top 1@current_page_pk = pk,@exec_script = script FROM Z$SP q where file_name='//Default/404' ;                        
    end      
	 

	 
	-- select 'sc',exec_script;
    if (@exec_script is null) begin
           set @info=concat('No script named : ',COALESCE(@ScriptNamed,'')); 
        END
        ELSE BEGIN            
			set @script_exec = replace(@exec_script,'-- assign_params',COALESCE(@page_params,''));
			-- extract variables from page_params
			
--			if (@page_params_in<>'') begin						
--					PREPARE stmt1x FROM @page_params_in;      
--					EXECUTE stmt1x;       
--					DEALLOCATE PREPARE stmt1x; 
--					-- select 'params ',@page_params_in,@run_procedure;
--			end  			
	
			
		set @NIN_SESSIONID  =   '@Z$SESSIONID' ; -- nvarchar(40);

		set @script_exec   =  concat( @exec_script , N'  @IN_SESSIONID            , @CID, @PKREF , @NEW_CID output, @INFO output, @res output');
		set @script_params =                      N'  @IN_SESSIONID varchar(40), @CID INTEGER  ,@PKREF INTEGER  , @NEW_CID INTEGER  OUTPUT , @INFO VARCHAR(1000) OUTPUT , @res VARCHAR(max) OUTPUT ';

		EXECUTE sp_executesql 
			@Query  = @script_exec, 
			@Params = @script_params,
			@IN_SESSIONID = @IN_SESSIONID, 
			@CID=@IN_CID,
			@PKREF=@IN_PKREF , 
			@NEW_CID=@NEW_CID output, 
			@INFO=@INFO output, 
			@res=@res output ;

	END;
END^
SET TERM ; ^




-- --------------------------------------------------------------------------------

SET TERM ^ ;
CREATE procedure Z$ONCE(
	@CONTEXT VARCHAR(80),
	@INITIAL_TIMES INTEGER,
	@PROGRESSIVE_TIMES INTEGER,
	@MAX_TIMES INTEGER,
	@DO_SHOW INTEGER OUTPUT
    ) 
    AS
BEGIN
    DECLARE @counter integer = 0; 
    -- This is to popup once and/or occationally remind the user of some action 
    -- It also has a "_disable" Context that will disable the reminder 
    set @DO_SHOW=0;
    select top 1 @counter = valu from Z$VARIABLES where Z$VARIABLES.REF=concat(@CONTEXT,'_disable') ;
    if (@counter=0) BEGIN
    
        select top 1 @counter = valu from Z$VARIABLES where Z$VARIABLES.REF=@CONTEXT ;
        if (@counter<1) 
		          INSERT INTO Z$VARIABLES (REF,VALU) VALUES (@CONTEXT,1);
        ELSE		  
                UPDATE Z$VARIABLES SET VALU=@counter+1 WHERE Z$VARIABLES.REF=@CONTEXT ;
		  
        IF (@counter<@MAX_TIMES) 
		      BEGIN            
                if (@counter<@INITIAL_TIMES) begin set @DO_SHOW=1; END 
                if ((@counter %@PROGRESSIVE_TIMES)=0) begin set @DO_SHOW=1; END 
            END					 		  
     
    END

        
      
END; ^
SET TERM ; ^

-- --------------------------------------------------------------------------------



dialect()

#>



