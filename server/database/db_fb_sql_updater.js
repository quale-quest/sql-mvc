"use strict";
/*
speed/memory performance  is not important
ease of use is important
 */

/*
Purpose is to execute model code against the database to perform DDL operations.
To automate the DDL maintenance.
 */

/*

#Guidelines
The following is some guidelines.

#General
Updating a production  SQL database is always a challenge for the following reasons:
 * Data integrity is the number one concern.
 * Referral integrity, Stored procedures, triggers and views depend on the table structures,
this makes it almost impossible sometimes to change a table. The intricacy  mean a programmer
has to plan a upgrade path and implement a process.
 * often this this would involve
1) taking the database off-line (single user mode).
2) deleting some or all triggers, stored procedures, views and referral integrity.
4) altering simple columns.
5) creating new columns, copying / transforming data, drop the old columns, rename the new columns back.
6) recreating triggers, stored procedures, views and referral integrity.
 * this process is much to delicate to automate without extensive testing.
 * for this reason organisations often don't allow programmers to make such changes and rather
have (highly paid)dedicated database administrators for such tasks.


Updating a development database is fortunately not so bad because data integrity is not a concern, but development time is.
so it is ok to "trust" a automated process on a dev database.

So on a production database the compiler won't attempt any DDL updates, it trusts the models match the actual database.

During early stages of development it useful not to have to much referral integrity, as it makes such updates difficult,
add it in during later stages of development.
(it would be nice in this updater code to to be able to switch of referral integrity.)

#updater features
##during application compiling.
 * can do simple table changes(or create) according to model files.
 * can add indexes, triggers and stored procedures.
 * can populate demo data according to simple scripts.

##command line
 * can export a schema update script from the development database.
 * can import the schema update script to another database.


#Workflow
 * create database - command line   sql-mvc database [-a application] new_name
 * update/add model files.
 * update / add application pages.
 * the compiler will see the model changes and update the database schema.
 * test the application.
 * export the schema update script, and review, possibly keep in GIT for version control.
 * clone the production box including database to a sandbox.
 * update the sandbox to the new upp and test.
 * clone the production box including database to a backup / standby.
 * optionally take the production box off-line
 * update the production box to the new app and test.
 * bring the production box on-line

 */

/*
Ported from UpdateFDB.py
#Warnings
#   Don't run this against your live databases without extensive testing for suitability
#   the effects on tables with referral integrity is unknown


#NOTES
#   much of this process has been inspired by Flamerobin, especially DDL extract and how they create empty procedures before the tables.
#   Supports firebird 2.0 and 2.5 (CREATE OR ALTER VIEW)
#
#   The parsing is quite simple and relies on expected behaviour
#   we assume the ddl file was generated by Flamerobin (extract ddl).
#   we want to keep comments that form part of procedures - thus we cannot just strip all comments.
#   we presume ; , SET TERM ; ^ and SET TERM ^ ; is not going to appear somewhere in comments, and will always be on the start of the line.
#   we presume that terminating ; will always be at the end of a line and no joining of lines or comments after will occur.
#   we presume the table fields will always be on one and only one line and the terminator ); will always be on its own line
#   The process will not delete tables or fields that no longer exist in the source

#Improvements
#   for more detailed parsing: http://pyparsing.wikispaces.com/
#   Referral integrity?
#   Output info on tables and fields that could be deleted manually

#
#Issues
# The FDB driver seems to be stuck in dialect 2, no matter that you specify 1 or 3 this results in:
#   Date fields throw an error: DATE must be changed to TIMESTAMP - even with "cast (tsf as DATE)" which is a real big problem- code has to be rewritten with Extract
#   convert as:  select cast(extract(day from cast('now' as timestamp))||'.'||extract(month from cast('now' as timestamp))||'.'||extract(year from cast('now' as timestamp)) as timestamp) from RDB$DATABASE
#   Quoted identifiers  throw an error  : a string constant is delimited by double quotes, -104, 335544569

 */
var fs = require('fs');
var deepcopy = require('deepcopy');

exports.module_name = 'db_fb_updater.js';

var countLines = function (str) {
	return (str.match(/\n/g) || []).length;
};
//http://stackoverflow.com/questions/25058134/javascript-split-a-string-by-comma-except-inside-parentheses
function splitNoParen(s, delim) { //Lafras enhanced to do quotes
	//console.log("splitNoParen :", s);
	var left = 0,
	right = 0,
	A = [],
	Q = 0,
	M = s.match(/([^()']+)|([()'])/g);
	if (!M)
		return A;
	var
	L = M.length,
	next,
	str = '',
    dbg=0;
	//var del_regx = new RegExp("([^" + (delim) + "]+)", 'g'); //anything except the delimiter
	if (dbg) console.log("splitNoParen:", L, M);
	for (var i = 0; i < L; i++) {    
		next = M[i];       
        //console.log("             xx:",str, ' n:', next, left, right);
		if (next === "'" && Q === 0) {
			++left;
			Q = 1;
		} 
        if (next === '(')
			++left;

		if ((left !== right)&&(i !== (L-1))) {
			str = str + next;
			if (dbg) console.log("accumulate :", str, left, right,' m:');
            }
        
        if ((left === right)||(i === (L-1))) {
			//var add=next.match(del_regx);
			var add = next.split(delim);
			if (dbg) console.log("Appending :", str,next, add);
            str+=add.shift();
            if (dbg) console.log(".....ding :", str, add);
            if (A.length===0) A.push('');
            A[A.length-1]+=str;
			A = A.concat(add);
            str='';
		}
        
        
        if (next === ')')
			++right;
        if (next === "'" && Q === 1) {
			++right;
			Q = 0;
		}         
        
	}
	return A;
}

function block_comment_suppress(inputs) {
	//replaces / * * / style comments with spaces (keeps line an col numbering consistent compared to the source)
	var rep_chr = " ";
	while (1) {
		var m = inputs.match(/([\S\s]*)(\/\*[\S\s]*\*\/)([\S\s]*)/i);
		if (m === null)
			break;
		//console.log('comment_replace : ',m[2]);

		var cr = m[2].replace(/\S/g, rep_chr);
		//console.log('comment_replace cr: ',cr);
		inputs = m[1] + cr + m[3];
	}

	//console.log('done ',inputs);
	return inputs;
}

function inline_comment_suppress(inputs) {
	//replaces --style comments with spaces (keeps line an col numbering consistent compared to the source)
    inputs = inputs.replace(/--[\s\S]*?$/gmi,'');
	return inputs;
}
function comment_suppress(inputs) {
   return inline_comment_suppress(block_comment_suppress(inputs));
}

var zx = require('../compiler/zx.js');

function dll_blocks_seperate_term(inputs, src_obj) { //splits the input into blocks that are in set term and blocks out side

	//function interpret_sorting_order(block){    }
	//console.log('dll_blocks_seperate_term start  A :', inputs, ':z');//.substring(0,20));
	var open_term = ";";
	var blocks = [];
	while (inputs !== '') {
		//console.log('dll_blocks_seperate_term :', inputs);
		var regs = '([\\S\\s]*?)set\\s+term\\s+(.)\\s+\\' + open_term + '([\\S\\s]*)';
		//  ([\S\s]*)set\s+term\s+(.)\s+;([\S\s]*)
		var re = new RegExp(regs, 'i');
		var m = inputs.match(re);
        //console.log('dll_blocks_seperate_term split  B :', m, '<<<<<y');
		if (!m)
			m = [0, inputs, ';', ''];

		var l = countLines(m[1]);
		inputs = m[3];

		//remove xtra lines and terminator

		var t = m[1].replace(/\s+$/g, '');

		//console.log('remove leading lines  a :', m[1].substring(0,20));
		//console.log('remove leading lines  b :', t.substring(0,20));

		if (t.slice(-1) === open_term)
			t = t.slice(0, -1);

		//remove leading lines
		//console.log('remove leading lines b4 :',open_term, m[1].substring(0,20),'...',m[1].slice(-20));
		//var n = t.match(/(\s*)([\S\s]+)/i) || [0,  '',t, '']; ;
        //var n = [0, '', t, ''];
		//console.log('remove leading lines   :', n);
		var o = 0;//countLines(n[1]);

		if (open_term == ';') { //split into ;
			var statements = splitNoParen(t, ";") || [];
			//console.log('statements   :', open_term,statements.length,n[2].substring(0,30));
			//console.log('statements   :', open_term,statements.length,t);
            //console.log('statements []  :', open_term,statements);
			//console.log('last statement   :', statements.slice(-1));

			for (var indx = 0; indx < statements.length; indx++) {
				var statement = statements[indx];
				//console.log('    statement   :', indx, zx.show_longstring(statement));
				//if (/*indx==1&&*/statement.match('PK_CACHE2')) process.exit(2);
				var ms = statement.match(/(\s*)([\S\s]+)/i); //remove leading lines
				//console.log('    statement   :', ms);
				l = countLines(ms[2]);
				o += countLines(ms[1]);
				var block = {
					t : ';',
					q : ms[2] + ';\n\n',
					src : {
						l : l,
						o : o,
						src_obj : src_obj //lots of lines can share the same source file object
					}
				};
				//interpret_sorting_order(block);
				blocks.push(block);

				o = 0;

			}
		} else {
			//console.log('bblock   :', open_term,n[2].substring(0,30));
			var bblock = {
				t : open_term,
				q : t, //driver dont need set term //"\nSET TERM ^ ;\n"+ n[2] + "\nSET TERM ; ^\n\n",
				src : {
					l : l - o,
					o : o,
					src_obj : src_obj //lots of lines can share the same source file object
				}
			};
			//interpret_sorting_order(block);
			blocks.push(bblock);
		}

		open_term = m[2];
	}
	//console.log('dll_blocks_seperate_term  :', blocks);
	return blocks;
}

var exec_qry = function (cx, qrys) {

	exports.write_log.push(qrys);
	//console.log('exports.write_log.push  :', qrys);
	//console.log('exports.write_log.push  :', cx.zx.line_obj.srcinfo );

	if (cx.zx.config.db.schema_mode !== "slave") {
		//console.log('exec_qry_cb.sync  :', qrys );
		cx.zx.dbu.exec_qry_cb.sync(null, cx, "exec_qry", qrys, cx.zx.line_obj);
	}
	delete cx.expect;
};

var dataset = function (zx, qrys) {//could use the one from sql_utils
	var res = zx.dbu.dataset.future(null, {
			zx : zx
		}, "updater dataset", qrys, 0);
	//console.log("dataset:" ,res.result);
	return res.result;
};
var singleton = function (zx, field, qrys) {//could use the one from sql_utils
	var res = zx.dbu.dataset.future(null, {
			zx : zx
		}, "updater singleton", qrys, 0);

	if (res.result[0] === undefined) {
		console.log("singleton:", res.result);
	}
	if (res.result[0][field] !== undefined) {
		//console.log("singleton:" ,res.result[0][field].low_)
		if (res.result[0][field].low_ === undefined)
			return res.result[0][field];
		return res.result[0][field].low_ + (res.result[0][field].high_ * 65536 * 65536);
	} else
		return '';
};
var checkTable = function (zx, name) {
	return singleton(zx, "count", "select count(*) from rdb$relations where rdb$relation_name ='" + name.toUpperCase() + "' ;");
};
var checkView = function (zx, name) {
	return singleton(zx, "count", "select count(*) from rdb$relations where rdb$relation_name ='" + name + "' AND (rdb$view_blr IS NOT NULL);");
};
var checkGenerator = function (zx, name) {
	return singleton(zx, "count", "SELECT count(*) FROM RDB$GENERATORS  where RDB$GENERATOR_NAME='" + name + "' ;");
};
var getGenerator = function (zx, name, increment) {
	return singleton(zx, "gen_id", "SELECT GEN_ID( " + name + "," + increment + " ) FROM RDB$DATABASE;");
};
var dropTriggers = function (zx) {
	var t = dataset(zx, "select rdb$trigger_name from rdb$triggers where (rdb$system_flag = 0 or rdb$system_flag is null)");
	//console.log("dropTriggers:",t);
	t.forEach(function (rec) {
		var sql = "drop trigger " + rec.rdb$trigger_name;
		console.log("dropTriggers forEach:", rec.rdb$trigger_name);
		exec_qry({
			zx : zx
		}, sql);
	});
	return t.length;
};

var dropProcedures = function (zx) {
	//remove the code from procedure - alternative to drop/create empty which has a dependency issue
	dropTriggers(zx);
	var count = 0;
	var totaldropped;
	//each loop any independent procs are dropped, thereby freeing dependencies of the other procs
	while (count++ < 10) //limit the loops in case a procedure cant be dropped
	{
		var t = dataset(zx, 'SELECT rdb$procedure_name FROM rdb$procedures ' +
				'WHERE rdb$system_flag IS NULL OR rdb$system_flag = 0;');
		console.log("DropProcedures :", t);
		if (totaldropped === null)
			totaldropped = t.length;
		if (t.length === 0)
			break;
		for (var indx = 0; indx < t.length; indx++) {
			var rec = t[indx];

			var sql = "drop procedure " + rec.rdb$procedure_name;
			console.log("DropProcedures forEach:", rec.rdb$procedure_name);

			exec_qry({
				zx : zx,
				expect : /335544673/
			}, sql);
		}
	}
	return totaldropped;

};
var dropDependecies = function (zx) {
	if (zx.config.db.schema_mode !== "master")
		return; //safeguard against deleting someone else's procedures
	//drop constraints // FOREIGN KEY Constraint
	dropTriggers(zx);
	dropProcedures(zx);

};
var CREATE_TABLE = function (zx, qrystr) {
	var cx = {
		zx : zx
	};
	var barestr = comment_suppress(qrystr); 
	var Table = barestr.match(/CREATE\s+TABLE\s+([\w$]+)(\s*\(\s)([\S\s]*)\)/i);
	if (!Table)
		Table = barestr.match(/CREATE\s+GLOBAL\s+TEMPORARY\s+TABLE\s+([\w$]+)(\s*\(\s)([\S\s]*)\)/i);
	if (!Table)
		{//did not understand try to create as is
        console.log('Could not undestand the table code - attempt to update as is');
		exec_qry(cx, qrystr);
		return "";
	} 
	barestr = Table[3];
    //onsole.log('Table re:', Table, barestr,' >',qrystr,'[',Table);
	Table = Table[1];
	
	var tableexists = checkTable(zx, Table);
	//console.log("CREATE_TABLE:",Table,tableexists,"qrystr:",qrystr," barestr:",barestr);
	if (tableexists === 0) // create new table as is
	{
        console.log('Table does not exist  - attempt to create as defined '+Table);
		exec_qry(cx, qrystr);
		return "";
	}

	var fields = splitNoParen(barestr, ',');
	var FieldNumber = 0;
	//console.log('Table fields:',fields );

	fields.forEach(function (field) {
		field = field.trim();
		if ((field !== ")" && field !== ";")) {
			FieldNumber = FieldNumber + 1;
			cx.expect = /335544351/;
			exec_qry(cx, "ALTER TABLE " + Table + " ADD " + field);
            if (cx.zx.config.db.schema_alter_fields === "yes") { 
			if (field.match(/\sblob\s/i) || field.match(/\sCOMPUTED BY\s/i)) {
				//Blobs cant be altered
				//Computed by gets dropped as part of cleanup ??WTF
			} else {

				var FFD = field.match(/(\S+)\s+(\S+)\s?(default)?\s?(not\s+null)?\s?(.*)/i);
				//console.log('Table fields FFD:', field, FFD);
				if (FFD) {
					var FieldName = FFD[1],
					FieldType = FFD[2],
					Default = FFD[5];
					if (FFD[4])
						console.log('WARN: Cannot update "NOT NULL" property for :', Table + '.' + FieldName);
                    cx.expect = /335544351/;    
					exec_qry(cx, "ALTER TABLE " + Table + " alter " + FieldName + " TYPE " + FieldType);
					if (Default !== "") {
                        cx.expect = /335544351/; 
						exec_qry(cx, "ALTER TABLE " + Table + " Alter " + FieldName + " set DEFAULT " + Default);
						// updating the default before commit seems a problem ... this should be moved to phase 2
						//caused an error in carlton update ->    exec_qry("update "+Table +" set " + FieldName + "="+Default+" where " +FieldName + " is null ")
					} else {
                        
						cx.expect = /335544351/;
						exec_qry(cx, "ALTER TABLE " + Table + " Alter " + FieldName + " DROP DEFAULT ");
                        
					}
                                            
                    if (cx.zx.config.db.schema_reorder_fields === "yes") { 
                        cx.expect = /335544351/; 
						exec_qry(cx, "ALTER TABLE " + Table + " ALTER " + FieldName + " POSITION " + FieldNumber);						
                    }
				}
			}
            }
		}
	});

	return "";
};

exports.Prepare_DDL = function (zx, filename, inputsx, line_obj) {

	var inputs;
	if ((inputsx === null) || (inputsx === undefined))
		inputs = fs.readFileSync(filename, 'utf8');
	else
		inputs = inputsx;

	//inputs = comment_replace(inputs);
	//console.log('Prepare_DDL  :', inputs.length);
	var LineNr = 1;
	var BlockNr = exports.blocks.length;
	var insertmatchingfield = '';
	var insertmatchingblock;
	var verbosity = 10;

	//exports.input_audit.push(inputsx);
	//exports.input_audit.push(JSON.stringify(line_obj,null,4));//.start_line + ' ' + line_obj.filename);
	var blocks = dll_blocks_seperate_term(inputs, line_obj);
	exports.input_audit.push(JSON.stringify(blocks, null, 4)); //.start_line + ' ' + line_obj.filename);

	//exports.show_DDL(zx,"Creating",blocks);
	blocks.forEach(function (block, bi) {
		LineNr += block.src.o;
		BlockNr++;

		//add more context info to the block source
		if (block.method !== "DECLARE_PROCEDURE") //src line already set
			block.src.LineNr = LineNr;
		block.src.BlockNr = BlockNr;

		//console.log('blocks.forEach  :', LineNr, block);
		//if (verbosity > 2)
		//	console.log(" Preview DDL from line preview: ",  block.src.LineNr, ' for ', block.src.l + 1, ' lines');
		var qrystr = block.q;
		//console.log('blocks.forEach GENERATOR:',qrystr.match(/\s*CREATE\s+GENERATOR\s/i) );
		//statements that would be used in the make script


		qrystr = qrystr.replace(/^ALTER\s+PROCEDURE\s/i, "CREATE PROCEDURE ");
		block.method = "exec";
		block.qrystr = 'xxxxx';

		if (qrystr.match(/SET\s+VERBOSITY\s/i)) {
			var mv = qrystr.match(/SET\s+VERBOSITY\s+([\w\$]+)/i);
			if (mv) {
				verbosity = +mv[1];
				qrystr = "";
			}
			block.order = 100;
		} else if (qrystr.match(/CREATE\s+ROLE\s/)) {
			block.expect = /335544351/;
			block.order = 200;
		} else if (qrystr.match(/CREATE\s+DOMAIN\s/)) {
			block.expect = /335544351/;
			block.order = 300;
		} else if (qrystr.match(/DECLARE\s+EXTERNAL\s+FUNCTION\s/)) {
			block.expect = /335544351/;
			block.order = 400;
		} else if (qrystr.match(/CREATE\s+GENERATOR\s/i)) {
			block.expect = /335544351/;
			var mg = qrystr.match(/CREATE\s+GENERATOR\s([\w\$]+)/i);
            //console.log("checkGenerator  ",mg, 'as ',qrystr);
			if (mg && checkGenerator(zx, mg[1]))
                {
                //console.log(" checkGenerator:  exits");
				qrystr = "";
                }
			// else execute as is
			block.order = 500;
		} else if (qrystr.match(/SET\s+GENERATOR\s/i)) {
			var mgg = qrystr.match(/SET\s+GENERATOR\s+([\w\$]+)/i);
			//console.log("getGenerator  ",mgg, 'as ',qrystr);
			if (mgg) {
                if (checkGenerator(zx, mgg[1]))
                {
				var gv = getGenerator(zx, mgg[1], 0);
				//console.log("GENERATOR value :",gv," ");
                //console.log(" checkGenerator:  exits");
				if (gv > 0) {
					qrystr = "";
					//console.log("GENERATOR", mgg[1], "already set");
				}
                }
                else
                qrystr = "";
                
			}
			block.order = 600;
		} else if (qrystr.match(/CREATE\s+SEQUENCE\s/i)) {
			block.expect = /335544351/;
			var mc = qrystr.match(/CREATE\s+SEQUENCE\s([\w\$]+)/i);
			if (mc && checkGenerator(zx, mc[1]))
				qrystr = "";
			// else execute as is
			block.order = 500;
		} else if (qrystr.match(/ALTER\s+SEQUENCE\s/i)) {
			var msgg = qrystr.match(/ALTER\s+SEQUENCE\s+([\w\$]+)/i);
			//console.log(" ALTER+SEQUENCE:  ",msgg, 'as ',qrystr);
			if (msgg) {
				var gsv = getGenerator(zx, msgg[1], 0);
				//console.log("SEQUENCE value :",gsv," ");
				if (gsv > 0) {
					qrystr = "";
					console.log("SEQUENCE", msgg[1], "already set");
				}
			}
			block.order = 600;
		} else if (qrystr.match(/CREATE\s+TABLE/i)) {
			block.method = "TABLE";
			block.order = 700;
		} else if (qrystr.match(/CREATE\s+GLOBAL\s+TEMPORARY\s+TABLE\s/i)) {			
			block.method = "TABLE";
			block.order = 800;
		} else if (qrystr.match(/CREATE\s+INDEX\s/)) {
			block.expect = /335544351/;
			block.order = 900;
			//console.log("show CREATE INDEX:", qrystr);
		} else if (qrystr.match(/CREATE\s+VIEW\s/i)) {
			qrystr = qrystr.replace(/CREATE\s+VIEW\s/i, "CREATE OR ALTER VIEW ");
			block.order = 1000;
		} else if (qrystr.match(/CREATE\s+OR\s+ALTER\s+VIEW\s/i)) { //execute as is
			block.order = 1100;
		} else if (qrystr.match(/ALTER\s+VIEW\s/i)) { //execute as is
			block.order = 1200;
		} else if (qrystr.match(/CREATE\s+EXCEPTION\s/i)) {
			qrystr = qrystr.replace(/CREATE\s+EXCEPTION\s/i, "CREATE OR ALTER EXCEPTION ");
			block.order = 1300;
		} else if (qrystr.match(/CREATE\s+OR\s+ALTER\s+EXCEPTION\s/i)) { //execute as is
			block.order = 1400;
		} else if (qrystr.match(/CREATE\s+(?:OR\s+ALTER\s+)?PROCEDURE\s/i)) {
			qrystr = qrystr.replace(/CREATE\s+PROCEDURE\s/i, "CREATE OR ALTER PROCEDURE ");
			var DECLARE_PROCEDURE = deepcopy(block);
			DECLARE_PROCEDURE.method = "DECLARE_PROCEDURE";
			DECLARE_PROCEDURE.order = 850;
			DECLARE_PROCEDURE.qrystr = qrystr;
			blocks.push(DECLARE_PROCEDURE);
			block.order = 1500;
		} else if (qrystr.match(/ALTER\s+PROCEDURE\s/i)) {
			//execute as is
			block.order = 1700;
		} else if (qrystr.match(/CREATE\s+TRIGGER\s/i)) {
			qrystr = qrystr.replace(/CREATE\s+TRIGGER\s/i, "CREATE OR ALTER TRIGGER ");
			block.order = 1800;
		} else if (qrystr.match(/CREATE\s+OR\s+ALTER\s+TRIGGER/i)) { //execute as is
			block.order = 1900;
		} else if (qrystr.match(/GRANT\s/)) {
			block.expect = /335544351/;
			block.order = 2000;
		} else if (qrystr.match(/INSERT\s+MATCHING\s/i)) {
			block.order = 2100;
			var mi = qrystr.match(/INSERT\s+MATCHING\s+([\w\$,\s]+)/i);
			if (mi) {
				insertmatchingfield = mi[1];
				block.records = [];
				insertmatchingblock = block;
			}
			qrystr = "";
		} else if (qrystr.match(/INSERT\s+INTO\s/i)) {
			block.order = 2200;
			qrystr = qrystr.replace(/;\s+$/g, '');
			if (insertmatchingfield !== '') {
				qrystr = "update or " + qrystr + " matching(" + insertmatchingfield + ") ";
				block.qrystr = qrystr;				
				insertmatchingblock.records.push(block);
			}

		} else if (qrystr.match(/UPDATE\s/i)) {
			block.order = 2300;
		} else {

        
            var qrystrx = comment_suppress(qrystr).trim()
            block.order = 9999;
            if (qrystrx===''||qrystrx===';')
                {
                block.method = "bypass";
                }
                else
                {
			

			if (verbosity > 1) {
				console.log(" Unexpected DDL, from line : ",
					block.src.LineNr, ' lines:', block.src.l + 1, 'text:', qrystr, ' after:',
					blocks[bi ? bi - 1 : 0].q);
				zx.error.log_SQL_warning(zx, "Unexpected DDL :" + qrystr, zx.line_obj);
			}
            }
		}

		block.qrystr = qrystr;
		block.Hash = zx.ShortHash(qrystr);
		//console.log('Update block, :',block.order, block.qrystr );
		LineNr += block.src.l;
		//exports.show_DDL(zx,"working",blocks);
	});

	//console.log('Prepare_DDL blocks.length :', blocks.length);
	//exports.show_DDL(zx,"Adding",blocks);
	exports.blocks = exports.blocks.concat(blocks);
	//process.exit(2);
};

exports.show_DDL = function (zx, msg, blocks) {
	console.log("show_DDL------------------------------------>", msg, blocks.length);
	blocks.forEach(function (block, i) {
		//console.log(msg, i," : ");
		console.log(msg, i, block.order, block.src.BlockNr, block.method, block.Hash, zx.show_longstring(block.qrystr)); //qrystr||'');
		//if (block.qrystr===undefined)
		//        console.log('block.undefined:', i,block);
	});
	console.log("done show_DDL^^^^^^^^^^^^^^^^^^", msg);
}

exports.Sort_DDL = function (zx, blocks) {

	blocks.sort(function (a, b) {
		//console.log('Sort_DDL :', a.order , b.order);
		if (a.order !== b.order)
			return (a.order - b.order);
		else
			return (a.src.BlockNr - b.src.BlockNr);
	});
	var Hash = 0;
	var build_str = [];
	blocks.forEach(function (block, i) {
		var qrystr = block.qrystr;
        Hash += block.Hash; 
		if (block.method === 'DECLARE_PROCEDURE')
			qrystr = "DECLARE" + zx.show_longstring(qrystr);
		build_str.push(" BORDER:" + block.order + " BNR:" + block.src.BlockNr + " method:" + block.method + " SRC:" + qrystr);
	});
	return {
		Hash : Hash,
		build_str : build_str.join('\n')
	};
};
var DECLARE_PROCEDURE = function (cx, qrystr) {

	var m = qrystr.match(/([\S\s]*?AS\s)/i);
	if (m === null)
		return;

	//qrystr = "\n--->>>\n" +m[1] + "\nBEGIN END" + "\nSET TERM ; ^\n---<<<\n\n";

	qrystr = m[1] + "\nBEGIN END" + "\n";

	exec_qry(cx, qrystr);

};

exports.Execute_DDL = function (zx, blocks) {
	//console.log('exports.Execute_DDL length:', blocks.length);
	var cx = {
		zx : zx
	};
	blocks.forEach(function (block, i) {
		if (block.qrystr === undefined) {
			//console.log('block.qrystr===undefined:', i,block);
		} else {
			var qrystr = block.qrystr;
			cx.expect = block.expect;
			//console.log('exports.Execute_DDL item:', i,block.method,(qrystr||'').substring(0,40),'q:',(block.q||'').substring(0,40));
			var ex = block.src.src_obj.srcinfo;
			//delete block.src.src_obj.body;
			//delete block.src.src_obj.nonkeyd;

			//delete ex.source;
			// delete ex.q.query;

			//console.log('exports.Execute_DDL item:', i,block.src.LineNr);
			//console.log('exports.Execute_DDL item:', i,ex);
			//process.exit(2);
			if (1) {
				zx.line_obj = block.src; //.src_obj;
			} else {
				zx.line_obj.srcinfo = {};
				//in case the parser needs to throw an error
				zx.line_obj.srcinfo.main_page_name = ex.main_page_name;
				zx.line_obj.srcinfo.file_stack = ex.file_stack.slice(0);
				zx.line_obj.srcinfo.filename = ex.filename;
				//zx.line_obj.srcinfo.source = sourcestr;
				zx.line_obj.srcinfo.start_line = ex.start_line + block.src.LineNr;
				zx.line_obj.srcinfo.start_col = ex.start_col;
				zx.line_obj.srcinfo.current_tag_index = ex.current_tag_index;
				zx.line_obj.tag = block.src.src_obj.tag;
			}
			if (block.method === "TABLE") {
				
                CREATE_TABLE(zx,qrystr);
			} else if (block.method === "DECLARE_PROCEDURE") {
				qrystr = DECLARE_PROCEDURE(cx, qrystr);
			} else if (block.method === "bypass") {}
			else
				if (qrystr !== "") {
					//console.log(" Execute DDL from line ", block.src.LineNr, ' for ', block.src.l + 1, ' lines '); //'as ',qrystr);
					//			console.log(" Execute DDL from line ", LineNr, ' for ', block.src.l + 1, ' lines as ',qrystr);
					exec_qry(cx, qrystr);
				} else {
					//console.log(" Skipped DDL from line ", block.src.LineNr, ' for ', block.src.l + 1, ' lines '); //'as ',qrystr);
				}
		}
	});

};

function full_updgade(zx, ddl_filename_prefix) {
	/*
	global con
	try:

	con = fdb.connect(
	host=zxconf.get('zxconf', 'SQLServer', 0), database=(zxconf.get('zxconf', 'DatabaseFolder', 0)+zxconf.get('zxconf', 'DatabaseFile', 0)),
	user=zxconf.get('zxconf', 'UserName', 0), password=zxconf.get('zxconf', 'Password', 0),
	sql_dialect=3

	)
	#con.execute_immediate("SET SQL DIALECT 3")
	print 'dialect:',con.sql_dialect,'  Server version:',con.version,' FDB version',fdb.__version__

	except fdb.fbcore.DatabaseError:
	errors=str(sys.exc_info()[1])
	if (errors.find('335544344')>=0 and errors.find('No such file or directory')>=0):
	print "No such file or directory - attempting to create database";
	con = fdb.create_database(
	host=zxconf.get('zxconf', 'SQLServer', 0), database=(zxconf.get('zxconf', 'DatabaseFolder', 0)+zxconf.get('zxconf', 'DatabaseFile', 0)),
	user=zxconf.get('zxconf', 'UserName', 0), password=zxconf.get('zxconf', 'Password', 0),
	page_size=8192
	)
	else:
	raise sys.exc_info()[1], None, sys.exc_info()[2] #re throw
	 */

	/*    if os.path.exists('make.sql'):
	#only break if we make - else we just load
	dropTriggers()
	Execute_DDL('clean');
	con.commit()
	Execute_DDL('make');
	con.commit()

	Execute_DDL('load');
	// con.commit()
	Execute_DDL('load-b');
	Execute_DDL('load-c');
	Execute_DDL('load-d');
	 */

	//con.commit()
}

exports.Backup_DDL = function (zx, reflect, backup) {
	var result = zx.dbu.extract_dll.sync(null, zx);
	//console.log('extract_dll result is ',str.ddl);
	console.log('extract_dll result is ', result.err);
	if (backup) {
		var d = new Date();
		var df = (1900 + d.getYear()) + '_' + d.getMonth() + '_' + d.getDate() + ' ' + d.getHours() + '_' + d.getMinutes() + '_' + d.getSeconds();
		fs.writeFileSync(zx.output_folder + '/Audit/Before update on ' + df, result.ddl);
	}
	if (reflect) {
		fs.writeFileSync(zx.output_folder + 'reflect.sql', result.ddl);
	}

}

exports.update = function (zx) {
	//called several times from the input processor....exports.Prepare_DDL(zx, null, model_text)
	//console.log('exports.blocks length:', exports.blocks.length);

	if (exports.lastHash === null)
		try {
			exports.lastHash = JSON.parse(require('fs').readFileSync(zx.output_folder + 'update.hash').toString()).Hash;
		} catch (e) {}

	//exports.show_DDL(zx,"B4 Sort",exports.blocks);

	exports.rebuild = 1;
	var B = exports.Sort_DDL(zx, exports.blocks);

	fs.writeFileSync(zx.output_folder + 'prebuild.sql', B.build_str);
	//console.log('exports.Sort_DDL length:', exports.blocks.length,exports.lastHash,Hash);
	//exports.show_DDL(zx,"Afer Write",exports.blocks);
    
    
    if ((exports.lastHash !== null) && (exports.lastHash === B.Hash))
       {
       exports.write_log.push("Model meta hash indicates it has not changed..."+ B.Hash);
       //console.log("Model meta hash indicates it has not changed...", B.Hash);
       }
    
	if ((exports.lastHash === null) || (exports.lastHash !== B.Hash) || (zx.config.db.schema_rebuild==="always")) {
		//console.log('exports.Execute_DDL hashed:');
		exports.Backup_DDL(zx, 0, 1); //audit trail
		//exports.show_DDL(zx, "After sort b4 exec ", exports.blocks);
		exports.Execute_DDL(zx, exports.blocks, 0);
		exports.Backup_DDL(zx, 1, 0); //reflection.sql
	}
	//console.log('exports.write_log.length  :', exports.write_log.length);
	exports.lastHash = B.Hash;

	fs.writeFileSync(zx.output_folder + 'input.sql', exports.input_audit.join(''));
	fs.writeFileSync(zx.output_folder + 'build.sql', exports.write_log.join(''));
	fs.writeFileSync(zx.output_folder + 'update.hash', JSON.stringify({
			Hash : B.Hash
		}));

};

function recreate(zx, model_text) {}

exports.init = function (zx) {

	exports.lastHash = null;
	exports.src_obj = {};
	exports.blocks = [];
	exports.write_log = [];
	exports.input_audit = [];

};

exports.start_up = function (zx) {};

exports.unit_test = function (zx) {

	console.log('comment_suppress', comment_suppress("abc /* cdef \n  hij */  klm \n nmp/* and */ stuff"));

	console.log('checkTable(" Z$USER "):', checkTable(zx, " Z$USER "));
	var cx = {
		zx : zx,
		expect : /335544569/
	};
	exec_qry(cx, " ALTER TABLE " + " xTable " + " ADD " + " field varchar(20); ");
	cx = {
		zx : zx,
		expect : /335544561/
	};
	exec_qry(cx, " ALTER TABLE " + " xTable " + " ADD " + " field varchar(20); ");

	console.log('getGenerator:', getGenerator(zx, 'Z$CONTEXT_SEQ', 0));

	//console.log('CREATE_TABLE:', exports.CREATE_TABLE(zx,
	//		" CREATE TABLE TODO_MVC(REF PK not null, OWNER fk, NAME VARCHAR(100), STATUS VARCHAR(10), CREATED_STAMP TIMESTAMP DEFAULT 'now'); "));

	console.log('getGenerator:', getGenerator(zx, 'Z$CONTEXT_SEQ', 0));

	exports.Execute_DDL(zx, " / home / xie01 / Sites / sql / sql - mvc / install / demo_db_dll_x.sql ");
	//dropTriggers(zx);

	var result = zx.dbu.extract_dll.sync(null, zx);
	//console.log('extract_dll result is ',str.ddl);
	console.log('extract_dll result is ', result.err);

	//process.exit(2);

	//exports.Execute_DDL(zx, "/home/xie01/Sites/sql/sql-mvc/install/demo_db_dll_x.sql");

	//console.log('CREATE_TABLE:', exports.CREATE_TABLE(zx,
	//		" CREATE TABLE TODO_MVC(REF PK not null, OWNER fk, NAME VARCHAR(100), STATUS VARCHAR(10), CREATED_STAMP TIMESTAMP DEFAULT 'now'); "));
	//dropTriggers(zx);


	//var res = zx.dbu.singleton.future(null, cx, " query ",
	//" select count( * )from rdb$relations ",0);
	//console.log('Query result is ',res.result[0].count);

	//process.exit(2);


};

exports.unit_test_s = function (zx) {


console.log(JSON.stringify(splitNoParen('123;456;789;(abc;(123;456;789);default;);999', ';'), null, 4));
console.log(JSON.stringify(splitNoParen('123;456;789;(abc;(123;456;789) default;) 999', ';'), null, 4));
process.exit(2);
}

//var inputs = fs.readFileSync('test.txt', 'utf8');
//console.log(JSON.stringify(splitNoParen(inputs, ';'), null, 4));
//console.log(inline_comment_suppress('abc --def\nghi\nklm\n---none of this\nend')); 
//process.exit(2);
